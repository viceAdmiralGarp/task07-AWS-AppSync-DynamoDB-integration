export type Key = {
    [key: string]: AttributeValue;
};
export type AttributeValue = unknown;
export type AttributeValueList = AttributeValue[];
export type ConsistentRead = boolean;
export type PutItemInputAttributeMap = {
    [key: string]: AttributeValue;
};
export type AttributeMap = {
    [key: string]: AttributeValue;
};
export type AttributeName = string;
export type AttributeNameList = AttributeName[];
export type ExpressionAttributeNameMap = {
    [key: string]: AttributeName;
};
export type ExpressionAttributeNameVariable = string;
export type ExpressionAttributeValueMap = {
    [key: string]: AttributeValue;
};
export type ExpressionAttributeValueVariable = string;
export type ConditionCheckExpression = {
    expression: string;
    expressionNames?: ExpressionAttributeNameMap;
    expressionValues?: ExpressionAttributeValueMap;
    equalsIgnore?: string[];
    consistentRead?: boolean;
    conditionalCheckFailedHandler?: {
        strategy: 'Custom' | 'Reject';
        lambdaArn?: string;
    };
};
export type TransactConditionCheckExpression = {
    expression: string;
    expressionNames?: ExpressionAttributeNameMap;
    expressionValues?: ExpressionAttributeValueMap;
    returnValuesOnConditionCheckFailure: boolean;
};
export type DynamoDBExpression = {
    expression: string;
    expressionNames?: ExpressionAttributeNameMap;
    expressionValues?: ExpressionAttributeValueMap;
};
export type DynamoDBProjectionExpression = {
    expression: string;
    expressionNames?: Record<string, string>;
};
export type DynamoDBGetItemRequest = {
    operation: 'GetItem';
    key: Key;
    consistentRead?: ConsistentRead;
    projection?: DynamoDBProjectionExpression;
};
/**
 * @deprecated Use DynamoDBGetItemRequest
 */
export type DynamoDBGetItem = DynamoDBGetItemRequest;
export type DynamoDBPutItemRequest = {
    operation: 'PutItem';
    key: Key;
    attributeValues: PutItemInputAttributeMap;
    condition?: ConditionCheckExpression;
    customPartitionKey?: string;
    populateIndexFields?: boolean;
    _version?: number;
};
export type DynamoDBUpdateItemRequest = {
    operation: 'UpdateItem';
    key: Key;
    update: DynamoDBExpression;
    condition?: ConditionCheckExpression;
    customPartitionKey?: string;
    populateIndexFields?: boolean;
    _version?: number;
};
export type DynamoDBDeleteItemRequest = {
    operation: 'DeleteItem';
    key: Key;
    condition?: ConditionCheckExpression;
    customPartitionKey?: string;
    populateIndexFields?: boolean;
    _version?: number;
};
export type DynamoDBQueryRequest = {
    operation: 'Query';
    query: DynamoDBExpression;
    index?: string;
    nextToken?: string;
    limit?: number;
    scanIndexForward?: boolean;
    consistentRead?: boolean;
    select?: 'ALL_ATTRIBUTES' | 'ALL_PROJECTED_ATTRIBUTES';
    filter?: DynamoDBExpression;
    projection?: DynamoDBProjectionExpression;
};
export type DynamoDBScanRequest = {
    operation: 'Scan';
    index?: string;
    limit?: number;
    consistentRead?: boolean;
    nextToken?: string;
    totalSegments?: number;
    segment?: number;
    filter?: DynamoDBExpression;
    projection?: DynamoDBProjectionExpression;
};
export type DynamoDBSyncRequest = {
    operation: 'Sync';
    basePartitionKey?: string;
    deltaIndexName?: string;
    limit?: number;
    nextToken?: string;
    lastSync?: number;
    filter?: DynamoDBExpression;
};
export type DynamoDBBatchGetItemRequest = {
    operation: 'BatchGetItem';
    tables: {
        [tableName: string]: {
            keys: Key[];
            consistentRead?: boolean;
            projection?: DynamoDBProjectionExpression;
        };
    };
};
export type DynamoDBBatchDeleteItemRequest = {
    operation: 'BatchDeleteItem';
    tables: {
        [tableName: string]: Key[];
    };
};
export type DynamoDBBatchPutItemRequest = {
    operation: 'BatchPutItem';
    tables: {
        [tableName: string]: PutItemInputAttributeMap[];
    };
};
export type DynamoDBTransactGetItemsRequest = {
    operation: 'TransactGetItems';
    transactItems: {
        table: string;
        key: Key;
    }[];
};
export type DynamoDBTransactWriteItemsRequest = {
    operation: 'TransactWriteItems';
    transactItems: TransactItem[];
};
type TransactItem = TransactWritePutItem | TransactWriteUpdateItem | TransactWriteDeleteItem | TransactWriteConditionCheckItem;
type TransactWritePutItem = {
    table: string;
    operation: 'PutItem';
    key: Key;
    attributeValues: PutItemInputAttributeMap;
    condition?: TransactConditionCheckExpression;
};
type TransactWriteUpdateItem = {
    table: string;
    operation: 'UpdateItem';
    key: Key;
    update: DynamoDBExpression;
    condition?: TransactConditionCheckExpression;
};
type TransactWriteDeleteItem = {
    table: string;
    operation: 'DeleteItem';
    key: Key;
    condition?: TransactConditionCheckExpression;
};
type TransactWriteConditionCheckItem = {
    table: string;
    operation: 'ConditionCheck';
    key: Key;
    condition?: TransactConditionCheckExpression;
};
export type HTTPRequest<T extends string | Record<string, unknown>> = {
    method: 'PUT' | 'POST' | 'GET' | 'DELETE' | 'PATCH';
    params?: {
        query?: {
            [key: string]: any;
        };
        headers?: {
            [key: string]: string;
        };
        body?: T;
    };
    resourcePath: string;
};
export type HTTPResult = {
    statusCode: number;
    headers?: Record<string, string>;
    body: string;
};
export type RDSRequest = {
    statements: string[];
    variableMap: Record<string, unknown>;
    variableTypeHintMap: Record<string, string>;
};
type RDSColumnMetadata = {
    /**
     * Name of the column
     */
    name?: string;
    /**
     * The label for the column.
     */
    label?: string;
    /**
     * The database-specific data type of the column.
     */
    typeName?: string;
    /**
     * The name of the schema that owns the table that includes the column.
     */
    schemaName?: string;
    /**
     * The name of the table that includes the column.
     */
    tableName?: string;
    /**
     * A value that indicates whether the column is nullable.
     */
    nullable?: number;
    /**
     * A value that indicates whether the column increments automatically.
     */
    isAutoIncrement?: boolean;
    /**
     * A value that indicates whether the column is case-sensitive.
     */
    isCaseSensitive?: boolean;
    /**
     * The type of the column.
     */
    type?: number;
    /**
     * A value that indicates whether an integer column is signed.
     */
    isSigned?: boolean;
    /**
     * A value that indicates whether the column contains currency values.
     */
    isCurrency?: boolean;
    /**
     * The precision value of a decimal number column.
     */
    precision?: number;
    /**
     * The scale value of a decimal number column.
     */
    scale?: number;
    /**
     * The type of the column.
     */
    arrayBaseColumnType?: number;
};
type RDSStructValue = {
    attributes: RDSRecordColumnValue[];
};
type RDSRecordColumnValue = {
    /**
     * A NULL value.
     */
    isNull: boolean;
    /**
     * A value for a column of BIT data type.
     */
    bitValue: boolean;
    /**
     * A value for a column of big integer data type.
     */
    bigIntValue: number;
    /**
     * A value for a column of integer data type.
     */
    intValue: number;
    /**
     * A value for a column of double data type.
     */
    doubleValue: number;
    /**
     * A value for a column of real data type.
     */
    realValue: number;
    /**
     * A value for a column of string data type.
     */
    stringValue: string;
    /**
     * A value for a column of BLOB data type.
     */
    blobValue: ArrayBuffer;
    /**
     * An array of column values.
     */
    arrayValues: RDSRecordColumnValue[];
    /**
     * A value for a column of STRUCT data type.
     */
    structValue: RDSStructValue;
};
type RDSSqlStatementResult = {
    numberOfRecordsUpdated: number;
    records: Array<RDSRecordColumnValue[]>;
    columnMetadata: RDSColumnMetadata[];
};
export type RDSResponse = {
    sqlStatementResults: RDSSqlStatementResult[];
};
export type OpenSearchRequest = {
    operation: 'GET' | 'POST' | ' PUT' | 'HEAD' | 'DELETE';
    path: string;
    params?: Partial<{
        headers: unknown;
        queryString: unknown;
        body: unknown;
    }>;
};
export type LambdaRequest = {
    operation: 'Invoke' | 'BatchInvoke';
    invocationType?: 'RequestResponse' | 'Event';
    payload: unknown;
};
export type NONERequest = {
    payload: unknown;
};
export type PutEventsRequest = {
    operation: 'PutEvents';
    events: {
        source: string;
        detail: {
            [key: string]: any;
        };
        detailType: string;
        resources?: string[];
        time?: string;
    }[];
};
export type PutEventsResult = {
    Entries: Array<{
        EventId: string;
    } | {
        ErrorCode: string;
        ErrorMessage: string;
    }>;
    FailedEntryCount: number;
};
/**
 * Bedrock Invoke Model
 */
export type BedrockInvokeModelRequest = {
    operation: 'InvokeModel';
    modelId: string;
    body: any;
    guardrailIdentifier?: string;
    guardrailVersion?: string;
    guardrailTrace?: string;
};
export type BedrockInvokeModelResult = any;
/**
 * Bedrock Converse
 */
export type BedrockConverseRequest = {
    operation: 'Converse';
    modelId: string;
    messages: BedrockMessage[];
    additionalModelRequestFields?: any;
    additionalModelResponseFieldPaths?: string[];
    guardrailConfig?: BedrockGuardrailConfig;
    inferenceConfig?: BedrockInferenceConfig;
    promptVariables?: {
        [key: string]: BedrockPromptVariableValues;
    }[];
    system?: BedrockSystemContent[];
    toolConfig?: BedrockToolConfig;
};
export type BedrockConverseResult = {
    output: BedrockConverseOutput;
    stopReason: 'end_turn' | 'tool_use' | 'max_tokens' | 'stop_sequence' | 'guardrail_intervened' | 'content_filtered' | string;
    usage: BedrockTokenUsage;
    metrics: BedrockConverseMetrics;
    additionalModelResponseFields?: any;
    trace?: BedrockConverseTrace;
};
export type BedrockMessage = {
    role: 'user' | 'assistant' | string;
    content: BedrockMessageContent[];
};
export type BedrockMessageContent = {
    text: string;
} | {
    guardContent: BedrockGuardContent;
} | {
    toolResult: BedrockToolResult;
} | {
    toolUse: BedrockToolUse;
};
export type BedrockGuardContent = {
    text: BedrockGuardContentText;
};
export type BedrockGuardContentText = {
    text: string;
    qualifiers?: ('grounding_source' | 'query' | 'guard_content' | string)[];
};
export type BedrockToolResult = {
    content: BedrockToolResultContent[];
    toolUseId: string;
    status?: string;
};
export type BedrockToolResultContent = {
    json: any;
} | {
    text: string;
};
export type BedrockToolUse = {
    input: any;
    name: string;
    toolUseId: string;
};
export type ConversePayload = {
    modelId: string;
    body: any;
    guardrailIdentifier?: string;
    guardrailVersion?: string;
    guardrailTrace?: string;
};
export type BedrockGuardrailConfig = {
    guardrailIdentifier: string;
    guardrailVersion: string;
    trace: string;
};
export type BedrockInferenceConfig = {
    maxTokens?: number;
    temperature?: number;
    stopSequences?: string[];
    topP?: number;
};
export type BedrockPromptVariableValues = {
    text: string;
};
export type BedrockToolConfig = {
    tools: BedrockTool[];
    toolChoice?: BedrockToolChoice;
};
export type BedrockTool = {
    toolSpec: BedrockToolSpec;
};
export type BedrockToolSpec = {
    name: string;
    description?: string;
    inputSchema: BedrockInputSchema;
};
export type BedrockInputSchema = {
    json: any;
};
export type BedrockToolChoice = {
    tool: BedrockSpecificToolChoice;
} | {
    auto: any;
} | {
    any: any;
};
export type BedrockSpecificToolChoice = {
    name: string;
};
export type BedrockSystemContent = {
    guardContent: BedrockGuardContent;
} | {
    text: string;
};
export type BedrockConverseOutput = {
    message?: BedrockMessage;
};
export type BedrockConverseMetrics = {
    latencyMs: number;
};
export type BedrockTokenUsage = {
    inputTokens: number;
    outputTokens: number;
    totalTokens: number;
};
export type BedrockConverseTrace = {
    guardrail?: BedrockGuardrailTraceAsssessment;
};
export type BedrockGuardrailTraceAsssessment = {
    inputAssessment?: {
        [key: string]: BedrockGuardrailAssessment;
    };
    modelOutput?: string[];
    outputAssessments?: {
        [key: string]: BedrockGuardrailAssessment;
    };
};
export type BedrockGuardrailAssessment = {
    contentPolicy?: BedrockGuardrailContentPolicyAssessment;
    contextualGroundingPolicy?: BedrockGuardrailContextualGroundingPolicyAssessment;
    invocationMetrics?: BedrockGuardrailInvocationMetrics;
    sensitiveInformationPolicy?: BedrockGuardrailSensitiveInformationPolicyAssessment;
    topicPolicy?: BedrockGuardrailTopicPolicyAssessment;
    wordPolicy?: BedrockGuardrailWordPolicyAssessment;
};
export type BedrockGuardrailContentPolicyAssessment = {
    filters: BedrockGuardrailContentFilter[];
};
export type BedrockGuardrailContentFilter = {
    action: 'BLOCKED' | string;
    confidence: 'NONE' | 'LOW' | 'MEDIUM' | 'HIGH' | string;
    type: 'INSULTS' | 'HATE' | 'SEXUAL' | 'VIOLENCE' | 'MISCONDUCT' | 'PROMPT_ATTACK' | string;
    filterStrength: 'NONE' | 'LOW' | 'MEDIUM' | 'HIGH' | string;
};
export type BedrockGuardrailContextualGroundingPolicyAssessment = {
    filters: BedrockGuardrailContextualGroundingFilter;
};
export type BedrockGuardrailContextualGroundingFilter = {
    action: 'BLOCKED' | 'NONE' | string;
    score: number;
    threshold: number;
    type: 'GROUNDING' | 'RELEVANCE' | string;
};
export type BedrockGuardrailInvocationMetrics = {
    guardrailCoverage?: BedrockGuardrailCoverage;
    guardrailProcessingLatency?: number;
    usage?: BedrockGuardrailUsage;
};
export type BedrockGuardrailCoverage = {
    textCharacters?: BedrockGuardrailTextCharactersCoverage;
};
export type BedrockGuardrailTextCharactersCoverage = {
    guarded?: number;
    total?: number;
};
export type BedrockGuardrailUsage = {
    contentPolicyUnits: number;
    contextualGroundingPolicyUnits: number;
    sensitiveInformationPolicyFreeUnits: number;
    sensitiveInformationPolicyUnits: number;
    topicPolicyUnits: number;
    wordPolicyUnits: number;
};
export type BedrockGuardrailSensitiveInformationPolicyAssessment = {
    piiEntities: BedrockGuardrailPiiEntityFilter[];
    regexes: BedrockGuardrailRegexFilter[];
};
export type BedrockGuardrailPiiEntityFilter = {
    action: 'BLOCKED' | 'ANONYMIZED' | string;
    match: string;
    type: 'ADDRESS' | 'AGE' | 'AWS_ACCESS_KEY' | 'AWS_SECRET_KEY' | 'CA_HEALTH_NUMBER' | 'CA_SOCIAL_INSURANCE_NUMBER' | 'CREDIT_DEBIT_CARD_CVV' | 'CREDIT_DEBIT_CARD_EXPIRY' | 'CREDIT_DEBIT_CARD_NUMBER' | 'DRIVER_ID' | 'EMAIL' | 'INTERNATIONAL_BANK_ACCOUNT_NUMBER' | 'IP_ADDRESS' | 'LICENSE_PLATE' | 'MAC_ADDRESS' | 'NAME' | 'PASSWORD' | 'PHONE' | 'PIN' | 'SWIFT_CODE' | 'UK_NATIONAL_HEALTH_SERVICE_NUMBER' | 'UK_NATIONAL_INSURANCE_NUMBER' | 'UK_UNIQUE_TAXPAYER_REFERENCE_NUMBER' | 'URL' | 'USERNAME' | 'US_BANK_ACCOUNT_NUMBER' | 'US_BANK_ROUTING_NUMBER' | 'US_INDIVIDUAL_TAX_IDENTIFICATION_NUMBER' | 'US_PASSPORT_NUMBER' | 'US_SOCIAL_SECURITY_NUMBER' | 'VEHICLE_IDENTIFICATION_NUMBER' | string;
};
export type BedrockGuardrailRegexFilter = {
    action: 'BLOCKED' | 'ANONYMIZED' | string;
    match?: string;
    name?: string;
    regex?: string;
};
export type BedrockGuardrailTopicPolicyAssessment = {
    topics: BedrockGuardrailTopic[];
};
export type BedrockGuardrailTopic = {
    action: 'BLOCKED' | string;
    name: string;
    type: 'DENY' | string;
};
export type BedrockGuardrailWordPolicyAssessment = {
    customWords: BedrockGuardrailCustomWord[];
    managedWordLists: BedrockGuardrailManagedWord[];
};
export type BedrockGuardrailCustomWord = {
    action: 'BLOCKED' | string;
    match: string;
};
export type BedrockGuardrailManagedWord = {
    action: 'BLOCKED' | string;
    match: string;
    type: 'PROFANITY' | string;
};
export {};
